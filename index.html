<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‹•ç”»ç·¨é›†ã‚¢ãƒ—ãƒª - Video Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            background: #e8ebff;
            border-color: #764ba2;
        }

        .upload-section input {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .video-preview {
            display: none;
            margin-top: 20px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            max-width: 100%;
        }

        #videoPlayer {
            width: 100%;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .subtitle-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .input-group input,
        .input-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .subtitle-list {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .subtitle-item {
            background: #f8f9ff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtitle-item-content {
            flex: 1;
        }

        .subtitle-item-text {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .subtitle-item-time {
            font-size: 0.9em;
            color: #666;
        }

        .subtitle-item-actions button {
            padding: 8px 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .subtitle-item-actions button:hover {
            background: #c82333;
        }

        .progress-section {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ å‹•ç”»ç·¨é›†ã‚¢ãƒ—ãƒª</h1>
            <p>å‹•ç”»ã®èª­ã¿è¾¼ã¿ã€ãƒ†ãƒ­ãƒƒãƒ—è¿½åŠ ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ãŒç°¡å˜ã«ã§ãã¾ã™</p>
        </div>

        <div class="main-content">
            <!-- å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="section">
                <h2 class="section-title">1. å‹•ç”»ã‚’èª­ã¿è¾¼ã‚€</h2>
                <div class="upload-section" onclick="document.getElementById('videoInput').click()">
                    <div class="upload-icon">ğŸ“</div>
                    <h3>å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</h3>
                    <p>ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</p>
                    <input type="file" id="videoInput" accept="video/*">
                </div>

                <div class="video-preview" id="videoPreview">
                    <div class="video-container">
                        <video id="videoPlayer" controls></video>
                        <canvas id="canvas"></canvas>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="playPause()">â–¶ï¸ å†ç”Ÿ/ä¸€æ™‚åœæ­¢</button>
                        <button class="btn" onclick="resetVideo()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                        <span id="currentTime">0:00 / 0:00</span>
                    </div>
                </div>
            </div>

            <!-- ãƒ†ãƒ­ãƒƒãƒ—è¿½åŠ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="section" id="subtitleSection" style="display: none;">
                <h2 class="section-title">2. ãƒ†ãƒ­ãƒƒãƒ—ã‚’è¿½åŠ ã™ã‚‹</h2>

                <div class="subtitle-controls">
                    <div class="input-group">
                        <label for="subtitleText">ãƒ†ãƒ­ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆ</label>
                        <input type="text" id="subtitleText" placeholder="è¡¨ç¤ºã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›">
                    </div>

                    <div class="input-group">
                        <label for="subtitlePosition">è¡¨ç¤ºä½ç½®</label>
                        <select id="subtitlePosition">
                            <option value="bottom">ä¸‹éƒ¨</option>
                            <option value="top">ä¸Šéƒ¨</option>
                            <option value="center">ä¸­å¤®</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="subtitleStart">é–‹å§‹æ™‚é–“ (ç§’)</label>
                        <input type="number" id="subtitleStart" min="0" step="0.1" value="0">
                    </div>

                    <div class="input-group">
                        <label for="subtitleEnd">çµ‚äº†æ™‚é–“ (ç§’)</label>
                        <input type="number" id="subtitleEnd" min="0" step="0.1" value="3">
                    </div>

                    <div class="input-group">
                        <label for="subtitleFontSize">ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º (px)</label>
                        <input type="number" id="subtitleFontSize" min="12" max="200" value="40">
                    </div>

                    <div class="input-group">
                        <label for="subtitleColor">ãƒ†ã‚­ã‚¹ãƒˆè‰²</label>
                        <input type="color" id="subtitleColor" value="#ffffff">
                    </div>
                </div>

                <div style="margin-top: 15px; text-align: center;">
                    <button class="btn" onclick="addSubtitle()">â• ãƒ†ãƒ­ãƒƒãƒ—ã‚’è¿½åŠ </button>
                    <button class="btn" onclick="previewSubtitles()">ğŸ‘ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
                </div>

                <div class="subtitle-list" id="subtitleList"></div>
            </div>

            <!-- ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="section" id="encodeSection" style="display: none;">
                <h2 class="section-title">3. ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦ä¿å­˜</h2>

                <div class="controls">
                    <button class="btn" onclick="startEncoding()">ğŸ¥ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰é–‹å§‹</button>
                    <button class="btn" onclick="downloadVideo()" id="downloadBtn" style="display: none;">ğŸ’¾
                        å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>

                <div class="progress-section" id="progressSection">
                    <h3>ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰é€²æ—</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                    <div id="statusMessage"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/mp4-muxer@4.3.3/build/mp4-muxer.js"></script>
    <script>
        let video;
        let canvas;
        let ctx;
        let subtitles = [];
        let videoEncoder;
        let audioEncoder;
        let muxer;
        let encodedVideoBlob = null;
        let isEncoding = false;
        let isPreviewing = false;
        let previewAnimationId = null;

        // åˆæœŸåŒ–
        window.onload = function () {
            video = document.getElementById('videoPlayer');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // ãƒ“ãƒ‡ã‚ªå…¥åŠ›ã®å‡¦ç†
            document.getElementById('videoInput').addEventListener('change', handleVideoUpload);

            // ãƒ“ãƒ‡ã‚ªã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æ™‚
            video.addEventListener('loadedmetadata', function () {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                updateTimeDisplay();
            });

            // æ™‚é–“æ›´æ–°
            video.addEventListener('timeupdate', updateTimeDisplay);

            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®ç¶™ç¶šçš„ãªæç”»
            video.addEventListener('timeupdate', () => {
                if (isPreviewing && !isEncoding) {
                    drawSubtitleOverlay(video.currentTime);
                }
            });

            video.addEventListener('play', () => {
                if (!isEncoding) {
                    startPreview();
                }
            });

            video.addEventListener('pause', () => {
                if (!isEncoding) {
                    stopPreview();
                }
            });

            // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å¯¾å¿œ
            const uploadSection = document.querySelector('.upload-section');
            uploadSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadSection.style.background = '#d8dcff';
            });

            uploadSection.addEventListener('dragleave', () => {
                uploadSection.style.background = '#f8f9ff';
            });

            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadSection.style.background = '#f8f9ff';
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('video/')) {
                    document.getElementById('videoInput').files = files;
                    handleVideoUpload({ target: { files: files } });
                }
            });
        };

        // å‹•ç”»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
        function handleVideoUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                video.src = url;
                document.getElementById('videoPreview').style.display = 'block';
                document.getElementById('subtitleSection').style.display = 'block';
                document.getElementById('encodeSection').style.display = 'block';

                // çµ‚äº†æ™‚é–“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
                video.addEventListener('loadedmetadata', function () {
                    document.getElementById('subtitleEnd').value = Math.min(video.duration, 3);
                }, { once: true });
            }
        }

        // å†ç”Ÿ/ä¸€æ™‚åœæ­¢
        function playPause() {
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }

        // ãƒªã‚»ãƒƒãƒˆ
        function resetVideo() {
            video.currentTime = 0;
            video.pause();
        }

        // æ™‚é–“è¡¨ç¤ºã®æ›´æ–°
        function updateTimeDisplay() {
            const current = formatTime(video.currentTime);
            const duration = formatTime(video.duration);
            document.getElementById('currentTime').textContent = `${current} / ${duration}`;
        }

        // æ™‚é–“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ãƒ†ãƒ­ãƒƒãƒ—ã‚’è¿½åŠ 
        function addSubtitle() {
            const text = document.getElementById('subtitleText').value;
            const position = document.getElementById('subtitlePosition').value;
            const start = parseFloat(document.getElementById('subtitleStart').value);
            const end = parseFloat(document.getElementById('subtitleEnd').value);
            const fontSize = parseInt(document.getElementById('subtitleFontSize').value);
            const color = document.getElementById('subtitleColor').value;

            if (!text) {
                alert('ãƒ†ãƒ­ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            if (start >= end) {
                alert('çµ‚äº†æ™‚é–“ã¯é–‹å§‹æ™‚é–“ã‚ˆã‚Šå¾Œã«ã—ã¦ãã ã•ã„');
                return;
            }

            const subtitle = {
                id: Date.now(),
                text,
                position,
                start,
                end,
                fontSize,
                color
            };

            subtitles.push(subtitle);
            updateSubtitleList();

            // å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('subtitleText').value = '';
        }

        // ãƒ†ãƒ­ãƒƒãƒ—ãƒªã‚¹ãƒˆã®æ›´æ–°
        function updateSubtitleList() {
            const list = document.getElementById('subtitleList');
            list.innerHTML = '';

            subtitles.forEach(sub => {
                const item = document.createElement('div');
                item.className = 'subtitle-item';
                item.innerHTML = `
                    <div class="subtitle-item-content">
                        <div class="subtitle-item-text">"${sub.text}"</div>
                        <div class="subtitle-item-time">
                            ${formatTime(sub.start)} - ${formatTime(sub.end)} | 
                            ä½ç½®: ${sub.position} | 
                            ã‚µã‚¤ã‚º: ${sub.fontSize}px | 
                            è‰²: ${sub.color}
                        </div>
                    </div>
                    <div class="subtitle-item-actions">
                        <button onclick="removeSubtitle(${sub.id})">å‰Šé™¤</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // ãƒ†ãƒ­ãƒƒãƒ—ã‚’å‰Šé™¤
        function removeSubtitle(id) {
            subtitles = subtitles.filter(sub => sub.id !== id);
            updateSubtitleList();
        }

        // ãƒ†ãƒ­ãƒƒãƒ—ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function previewSubtitles() {
            if (subtitles.length === 0) {
                alert('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹ãƒ†ãƒ­ãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            video.currentTime = 0;
            startPreview();
            video.play();
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹
        function startPreview() {
            isPreviewing = true;
            renderPreview();
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢
        function stopPreview() {
            isPreviewing = false;
            if (previewAnimationId) {
                cancelAnimationFrame(previewAnimationId);
                previewAnimationId = null;
            }
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ãƒ«ãƒ¼ãƒ—
        function renderPreview() {
            if (!isPreviewing) return;

            drawSubtitleOverlay(video.currentTime);
            previewAnimationId = requestAnimationFrame(renderPreview);
        }

        // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¨ã—ã¦ãƒ†ãƒ­ãƒƒãƒ—ã‚’æç”»
        function drawSubtitleOverlay(currentTime) {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ï¼ˆé€æ˜ã«ï¼‰
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // è©²å½“ã™ã‚‹ãƒ†ãƒ­ãƒƒãƒ—ã‚’æç”»
            subtitles.forEach(sub => {
                if (currentTime >= sub.start && currentTime <= sub.end) {
                    ctx.font = `bold ${sub.fontSize}px Arial`;
                    ctx.fillStyle = sub.color;
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.textAlign = 'center';

                    let y;
                    switch (sub.position) {
                        case 'top':
                            y = sub.fontSize + 20;
                            break;
                        case 'center':
                            y = canvas.height / 2;
                            break;
                        case 'bottom':
                        default:
                            y = canvas.height - 50;
                            break;
                    }

                    const x = canvas.width / 2;
                    ctx.strokeText(sub.text, x, y);
                    ctx.fillText(sub.text, x, y);
                }
            });
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ†ãƒ­ãƒƒãƒ—ã‚’æç”»
        function drawSubtitle(currentTime) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            subtitles.forEach(sub => {
                if (currentTime >= sub.start && currentTime <= sub.end) {
                    ctx.font = `bold ${sub.fontSize}px Arial`;
                    ctx.fillStyle = sub.color;
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.textAlign = 'center';

                    let y;
                    switch (sub.position) {
                        case 'top':
                            y = sub.fontSize + 20;
                            break;
                        case 'center':
                            y = canvas.height / 2;
                            break;
                        case 'bottom':
                        default:
                            y = canvas.height - 50;
                            break;
                    }

                    const x = canvas.width / 2;
                    ctx.strokeText(sub.text, x, y);
                    ctx.fillText(sub.text, x, y);
                }
            });
        }

        // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰é–‹å§‹ï¼ˆWebCodecs APIä½¿ç”¨ï¼‰
        async function startEncoding() {
            if (subtitles.length === 0) {
                alert('å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ†ãƒ­ãƒƒãƒ—ã‚’è¿½åŠ ã—ã¦ãã ã•ã„');
                return;
            }

            if (isEncoding) {
                alert('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­ã§ã™');
                return;
            }

            // WebCodecs APIã®ã‚µãƒãƒ¼ãƒˆç¢ºèª
            if (!window.VideoEncoder || !window.AudioEncoder) {
                alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯WebCodecs APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome 94ä»¥é™ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
                return;
            }

            const progressSection = document.getElementById('progressSection');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressSection.style.display = 'block';
            statusMessage.innerHTML = '<div class="status-message info">ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’æº–å‚™ä¸­...</div>';

            isEncoding = true;
            let audioContext = null;
            let audioReader = null;

            try {
                video.currentTime = 0;
                await new Promise(resolve => {
                    video.onseeked = resolve;
                });

                const width = video.videoWidth;
                const height = video.videoHeight;
                const fps = 30;
                const duration = video.duration;
                const totalFrames = Math.floor(duration * fps);

                // è§£åƒåº¦ã«å¿œã˜ã¦é©åˆ‡ãªAVCãƒ¬ãƒ™ãƒ«ã‚’é¸æŠ
                let codec;
                const pixelCount = width * height;
                if (pixelCount > 2073600) { // 1920x1080ã‚ˆã‚Šå¤§ãã„ï¼ˆ4Kç­‰ï¼‰
                    codec = 'avc1.640033'; // High Profile, Level 5.1 (4Kå¯¾å¿œ)
                } else if (pixelCount > 921600) { // 1280x720ã‚ˆã‚Šå¤§ãã„ï¼ˆ1080pï¼‰
                    codec = 'avc1.64001F'; // High Profile, Level 3.1
                } else {
                    codec = 'avc1.42E01E'; // Baseline Profile, Level 3.0
                }

                console.log(`Video resolution: ${width}x${height}, Using codec: ${codec}`);

                // MP4 Muxerã®åˆæœŸåŒ–
                muxer = new Mp4Muxer.Muxer({
                    target: new Mp4Muxer.ArrayBufferTarget(),
                    video: {
                        codec: 'avc',
                        width: width,
                        height: height
                    },
                    audio: {
                        codec: 'aac',
                        numberOfChannels: 2,
                        sampleRate: 48000
                    },
                    fastStart: 'in-memory'
                });

                // VideoEncoderã®è¨­å®š
                let frameCount = 0;
                let videoEncoderError = null;
                videoEncoder = new VideoEncoder({
                    output: (chunk, metadata) => {
                        muxer.addVideoChunk(chunk, metadata);
                    },
                    error: (error) => {
                        console.error('Video encoding error:', error);
                        videoEncoderError = error;
                    }
                });

                videoEncoder.configure({
                    codec: codec,
                    width: width,
                    height: height,
                    bitrate: 2_500_000,
                    framerate: fps,
                    latencyMode: 'quality'
                });

                statusMessage.innerHTML = '<div class="status-message info">ğŸ¬ ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­...</div>';

                // éŸ³å£°ã®å‡¦ç†ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
                let audioProcessingPromise = Promise.resolve();
                try {
                    audioContext = new AudioContext({ sampleRate: 48000 });
                    const audioSource = audioContext.createMediaElementSource(video);
                    const audioDestination = audioContext.createMediaStreamDestination();
                    audioSource.connect(audioDestination);
                    audioSource.connect(audioContext.destination);

                    // AudioEncoderã®è¨­å®š
                    let audioEncoderError = null;
                    audioEncoder = new AudioEncoder({
                        output: (chunk, metadata) => {
                            muxer.addAudioChunk(chunk, metadata);
                        },
                        error: (error) => {
                            console.error('Audio encoding error:', error);
                            audioEncoderError = error;
                        }
                    });

                    audioEncoder.configure({
                        codec: 'mp4a.40.2', // AAC-LC
                        numberOfChannels: 2,
                        sampleRate: 48000,
                        bitrate: 128_000
                    });

                    // éŸ³å£°ã‚­ãƒ£ãƒ—ãƒãƒ£ã®è¨­å®š
                    const audioStream = audioDestination.stream;
                    const audioTrack = audioStream.getAudioTracks()[0];
                    const audioProcessor = new MediaStreamTrackProcessor({ track: audioTrack });
                    audioReader = audioProcessor.readable.getReader();

                    // éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’éåŒæœŸã§èª­ã¿å–ã‚Š
                    audioProcessingPromise = (async () => {
                        try {
                            while (isEncoding) {
                                const { done, value } = await audioReader.read();
                                if (done) break;

                                if (audioEncoder && audioEncoder.state === 'configured') {
                                    audioEncoder.encode(value);
                                    value.close();
                                } else {
                                    value.close();
                                    break;
                                }
                            }
                        } catch (error) {
                            if (error.name !== 'AbortError') {
                                console.error('Audio processing error:', error);
                            }
                        }
                    })();
                } catch (audioError) {
                    console.warn('Audio processing disabled:', audioError);
                    // éŸ³å£°ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œ
                }

                // ãƒ•ãƒ¬ãƒ¼ãƒ å˜ä½ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
                for (let i = 0; i < totalFrames; i++) {
                    if (!isEncoding || videoEncoderError) break;

                    const timestamp = (i / fps) * 1_000_000; // ãƒã‚¤ã‚¯ãƒ­ç§’
                    const currentTime = i / fps;

                    // ãƒ“ãƒ‡ã‚ªã®ç¾åœ¨ä½ç½®ã‚’è¨­å®š
                    video.currentTime = currentTime;
                    await new Promise(resolve => {
                        if (video.readyState >= 2) {
                            resolve();
                        } else {
                            video.onseeked = resolve;
                        }
                    });

                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»ï¼ˆãƒ†ãƒ­ãƒƒãƒ—ä»˜ãï¼‰
                    drawSubtitle(currentTime);

                    // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
                    if (videoEncoderError) {
                        throw new Error('Video encoder error occurred: ' + videoEncoderError.message);
                    }

                    // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
                    if (videoEncoder.state !== 'configured') {
                        throw new Error('Video encoder is not in configured state: ' + videoEncoder.state);
                    }

                    // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®ã‚­ãƒ¥ãƒ¼ãŒä¸€æ¯ã«ãªã‚‰ãªã„ã‚ˆã†å¾…æ©Ÿ
                    while (videoEncoder.encodeQueueSize > 5) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }

                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰VideoFrameã‚’ä½œæˆ
                    const videoFrame = new VideoFrame(canvas, {
                        timestamp: timestamp,
                        duration: 1_000_000 / fps
                    });

                    // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
                    const keyFrame = i % 30 === 0; // 1ç§’ã”ã¨ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
                    try {
                        videoEncoder.encode(videoFrame, { keyFrame });
                    } catch (e) {
                        videoFrame.close();
                        throw new Error('Failed to encode frame ' + i + ': ' + e.message);
                    }
                    videoFrame.close();

                    frameCount++;

                    // é€²æ—æ›´æ–°
                    const progress = (frameCount / totalFrames) * 100;
                    progressFill.style.width = progress + '%';
                    progressFill.textContent = Math.round(progress) + '%';

                    // UIã®æ›´æ–°ã‚’è¨±å¯ï¼ˆã‚­ãƒ¥ãƒ¼å¾…æ©Ÿã¨çµ±åˆï¼‰
                    if (i % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
                if (videoEncoderError) {
                    throw new Error('Video encoding failed: ' + videoEncoderError.message);
                }

                // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å®Œäº†ã‚’å¾…ã¤
                statusMessage.innerHTML = '<div class="status-message info">â³ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚’å®Œäº†ã—ã¦ã„ã¾ã™...</div>';

                // ãƒ“ãƒ‡ã‚ªã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®flush
                if (videoEncoder.state === 'configured') {
                    await videoEncoder.flush();
                }

                // éŸ³å£°å‡¦ç†ã‚’åœæ­¢
                isEncoding = false;
                if (audioReader) {
                    await audioReader.cancel();
                }
                await audioProcessingPromise;

                // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®flush
                if (audioEncoder.state === 'configured') {
                    await audioEncoder.flush();
                }

                // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã‚’é–‰ã˜ã‚‹
                if (videoEncoder.state !== 'closed') {
                    videoEncoder.close();
                }
                if (audioEncoder.state !== 'closed') {
                    audioEncoder.close();
                }
                if (audioContext) {
                    await audioContext.close();
                }

                // MP4ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ
                muxer.finalize();
                const { buffer } = muxer.target;
                encodedVideoBlob = new Blob([buffer], { type: 'video/mp4' });

                progressFill.style.width = '100%';
                progressFill.textContent = '100%';
                statusMessage.innerHTML = '<div class="status-message success">âœ… ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å®Œäº†ï¼MP4å½¢å¼ã§ä¿å­˜ã§ãã¾ã™ã€‚</div>';
                document.getElementById('downloadBtn').style.display = 'inline-block';

            } catch (error) {
                console.error('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                statusMessage.innerHTML = '<div class="status-message error">âŒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message + '</div>';

                // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (videoEncoder && videoEncoder.state !== 'closed') {
                    videoEncoder.close();
                }
                if (audioEncoder && audioEncoder.state !== 'closed') {
                    audioEncoder.close();
                }
                if (audioContext && audioContext.state !== 'closed') {
                    await audioContext.close();
                }
            } finally {
                isEncoding = false;
                video.pause();
            }
        }

        // å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        function downloadVideo() {
            if (!encodedVideoBlob) {
                alert('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå‹•ç”»ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            const url = URL.createObjectURL(encodedVideoBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'edited-video-' + Date.now() + '.mp4';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>

</html>

</html>